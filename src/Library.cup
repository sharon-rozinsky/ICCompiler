import IC.AST.*;
import IC.Types.*;
import IC.Error.*;
import java_cup.runtime.*;

import java.util.ArrayList;
import java.util.List;

parser code {:

	private Lexer lexer;
	
	public LibraryParser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}

	/**
	 *	Causes the parser to print every reduction.
	 */
	public boolean printParsing = false;
	
	public void log(String message) {
		if (printParsing) {
			System.out.println(message);
		}
	}

	/**
	 * Causes the parser to print every token it reads.
	 */
	public boolean printTokens;
	
	/* all errors are unrecoverable */
	public void syntax_error(Symbol s) { }
	
	public void unrecovered_syntax_error(Symbol s) throws SyntaxError {
		report_fatal_error(null, s);
	}
	
	/* nothing to report, we will throw an exception instead and report outside */
	public void report_error(String message, Object info) { }
	
	public void report_fatal_error(String message, Object info) throws SyntaxError {
		done_parsing();
		Token tok = (Token) info;
		throw new SyntaxError(tok.getLine() + ":" + tok.getColumn() + " : "  +  message);
	}
	
:};

scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + Utils.getTokenName(t.getTag()));
	return t;
:};

terminal STRING;
terminal RETURN;
terminal CLASS;
terminal EXTENDS;
terminal STATIC;
terminal VOID;
terminal INT;
terminal BOOLEAN;
terminal STR;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal BREAK;
terminal CONTINUE;
terminal THIS;
terminal NEW;
terminal LENGTH;
terminal TRUE;
terminal FALSE;
terminal NULL;
terminal EQ;
terminal PLUS;
terminal MUL;
terminal SUB;
terminal DIV;
terminal EOL;
terminal MOD;
terminal ST;
terminal STEQ;
terminal GT;
terminal GTEQ;
terminal EQEQ;
terminal NOTEQ;
terminal AND;
terminal OR;
terminal COMMA;
terminal DOT;
terminal NOT;
terminal LP;
terminal RP;
terminal LRP;
terminal RRP;
terminal LSP;
terminal RSP;   

terminal String CLASS_ID;
terminal String ID;
terminal String INTEGER;
terminal String QUOTE;

// Precedence terminals
terminal UMINUS;

non terminal ICClass ICClass;
non terminal List<Method> LibraryMethods;
non terminal LibraryMethod LibraryMethod;
non terminal Type ReturnType;
non terminal Type Type;
non terminal List<Formal> Formals;
non terminal Formal Formal;

ICClass ::=
	CLASS CLASS_ID:classId LP LibraryMethods:libraryMethods RP
	{: 
		RESULT = new ICClass(classIdleft, classId, new ArrayList<Field>(), libraryMethods); 
	:} 
	| 
	CLASS CLASS_ID:classId LP RP
	{:
		RESULT = new ICClass(classIdleft, classId, new ArrayList<Field>(), new ArrayList<Method>());
	:}
;
LibraryMethods ::= 
	LibraryMethod:libraryMethod
	{:
		List<Method> methods = new ArrayList<Method>();
		methods.add(libraryMethod);
		RESULT = methods;
	:}
	| 
	LibraryMethods:libraryMethods LibraryMethod:libraryMethod 
	{:
		libraryMethods.add(libraryMethod);
		RESULT = libraryMethods;
	:} 
;
LibraryMethod ::= 
	STATIC ReturnType:returnType ID:id LRP Formals:formals RRP EOL 
	{:
		RESULT = new LibraryMethod(returnType, id, formals);
	:}
	|
	STATIC ReturnType:returnType ID:id LRP RRP EOL
	{:
		RESULT = new LibraryMethod(returnType, id, new ArrayList<Formal>());
	:}
;
ReturnType ::= 
	Type:type 
	{:
		RESULT = type;
	:} 
	| 
	VOID:voidTok
	{:
		RESULT = new PrimitiveType(voidTokleft, DataTypes.VOID);
	:}
;
Type ::= 
	INT:intTok 
	{:
		RESULT = new PrimitiveType(intTokleft, DataTypes.INT);
	:}
	| 
	BOOLEAN:boolTok
	{:
		RESULT = new PrimitiveType(boolTokleft, DataTypes.BOOLEAN);
	:} 
	| 
	STR:strTok
	{:
		RESULT = new PrimitiveType(strTokleft, DataTypes.STRING);
	:}  
	| 
	Type:type LSP RSP
	{:
		type.incrementDimension();
		RESULT = type;
	:}
;
Formals ::= 
	Formals:formals COMMA Formal:formal 
	{:
		formals.add(formal);
		RESULT = formals;
	:}
	| 
	Formal:formal
	{:
		List<Formal> formals = new ArrayList<Formal>();
		formals.add(formal);
		RESULT = formals; 
	:}
;
Formal ::= 
	Type:type ID:id
	{:
		RESULT = new Formal(type, id);
	:}
;