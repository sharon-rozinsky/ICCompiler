import IC.AST.*;
import IC.Types.*;
import IC.Error.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;

parser code {:

	private Lexer lexer;
	
	public IcParser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}

	/**
	 *	Causes the parser to print every reduction.
	 */
	public boolean printParsing = false;
	
	public void log(String message) {
		if (printParsing) {
			System.out.println(message);
		}
	}

	/**
	 * Causes the parser to print every token it reads.
	 */
	public boolean printTokens;
	
	/* all errors are unrecoverable */
	public void syntax_error(Symbol s) { }
	
	public void unrecovered_syntax_error(Symbol s) throws SyntaxError {
		report_fatal_error(null, s);
	}
	
	/* nothing to report, we will throw an exception instead and report outside */
	public void report_error(String message, Object info) { }
	
	public void report_fatal_error(String message, Object info) throws SyntaxError {
		done_parsing();
		Token tok = (Token) info;
		throw new SyntaxError(tok.getLine() + ":" + tok.getColumn() + " : "  +  message);
	}
	
:};

scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + Utils.getTokenName(t.getTag()));
	return t;
:};
////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

non terminal Program Program;
non terminal ICClass ICClass;
non terminal Statement Statement;
non terminal StatementsBlock StatementsBlock;
non terminal Type Type;

terminal ASSIGN;
terminal Integer INTEGER;
terminal STRING;
terminal RETURN;
terminal CLASS;
terminal EXTENDS;
terminal STATIC;
terminal VOID;
terminal INT;
terminal BOOLEAN;
terminal STR;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal BREAK;
terminal CONTINUE;
terminal THIS;
terminal NEW;
terminal LENGTH;
terminal TRUE;
terminal FALSE;
terminal NULL;
terminal EQ;
terminal PLUS;
terminal MUL;
terminal SUB;
terminal DIV;
terminal EOL;
terminal MOD;
terminal ST;
terminal STEQ;
terminal GT;
terminal GTEQ;
terminal EQEQ;
terminal NOTEQ;
terminal AND;
terminal OR;
terminal COMMA;
terminal DOT;
terminal NOT;
terminal LP;
terminal RP;
terminal LRP;
terminal RRP;
terminal LSP;
terminal RSP;   

terminal String CLASS_ID;
terminal String ID;
terminal String INTEGER;
terminal String QUOTE;

//////////////////////////
// Precedence declarations

//////////////
// The grammar

//Literal ::= INTEGER | NULL;

Program ::=
	ICClass:class
	{: 
		Program program = new Program(class);
	:}
	| Program:program ICClass:class
	{:
		program.add(class); RESULT = program;
	:}   
;

ICClass ::=
	CLASS CLASS_ID LP 


Statement ::= 
	Location:location ASSIGN Expression:expression EOL
	{:
		parser.log("Statement ::= Location ASSIGN Expression EOL");
		RESULT = new Assignment(location, expression);
	:} 
	|
	Call:call EOL
	{:
		parser.log("Statement ::= Call EOL");
		RESULT = new CallStatement(call);
	:}
	|
	RETURN:returnTok EOL
	{:
		parser.log("Statement ::= RETURN EOL");
		RESULT = new Return(returnTokleft);
	:}
	|
	RETURN:returnTok Expression:expression EOL
	{:
		parser.log("Statement ::= RETURN Expression EOL");
		RESULT = new Return(returnTokleft, expression);
	:}
	|
	IF LRP Expression:expression RRP Statement:statement
	{:
		parser.log("Statement ::= IF LRP Expression RRP Statement");
		RESULT = new If(expression, statement);
	:} 
	|
	IF LRP Expression:expression RRP Statement:ifStatement ELSE Statement:elseStatement
	{:
		parser.log("Statement ::= IF LRP Expression RRP Statement ELSE Statement");
		RESULT = new If(expression, ifStatement, elseStatement);
	:} 
	|
	WHILE RRP Expression:expression RRP Statement:statement
	{:
		parser.log("Statement ::= WHILE LRP Expression RRP Statement");
		RESULT = new While(expression, statement);
	:}
	|
	BREAK:breakTok EOL
	{:	
		parser.log("Statement ::= BREAK EOL");
		RESULT = new Break(breakTokleft);
	:}
	|
	CONTINUE:continueTok EOL
	{:
		parser.log("Statement ::= CONTINUE EOL");
		RESULT = new Continue(continueTokleft);
	:}
	|
	LP:lp RP
	{:
		parser.log("Statement ::= LP RP");
		RESULT = new StatementsBlock(lpleft, new ArrayList<Statement>());
	:}
	|
	LP:lp StatementsBlock:statementsBlock RP
	{:
		parser.log("Statement ::= LP StatemntsBlock RP");
		statementsBlock.setLine(lpleft);
		RESULT = statementsBlock;
	:}
	|
	Type:type ID:id EOL
	{:
		parser.log("Statement ::= Type ID EOL");
		RESULT = new LocalVariable(type, id);
	:}
	|
	Type:type ID:id ASSIGN Expression:expression EOL
	{:
		parser.log("Statement ::= Type ID ASSIGN Expression EOL");
		RESULT = new LocalVariable(type, id, expression);
	:} 
;	

StatementsBlock ::=
	Statement:statement
	{:
		List<Statement> statements = new ArrayList<Statement>();
		statements.add(statement);
		StatementsBlock block = new StatementsBlock(0 /* retrieved later */, statements);
		
		parser.log("StatementsBlock ::= Statement");
		RESULT = block;
	:}
	|
	StatementsBlock:statementsBlock Statement:statement
	{:
		statementsBlock.getStatements().add(statement);
		
		parser.log("StatementsBlock ::= StatementsBlock Statement");
		RESULT = statementsBlock;
	:}
;
			
